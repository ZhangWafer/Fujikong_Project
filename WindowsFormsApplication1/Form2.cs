using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading;  //引用多线程
using HalconDotNet;

namespace WindowsFormsApplication1
{
    public partial class Form2 : Form
    {
       // #region
        public static Form2 frm2 = null;
        public Form2()
        {
            InitializeComponent();
            frm2 = this;
        }

        //定义用到的Halcon变量
        public HTuple hv_ExpDefaultWinHandle;
        public HTuple hv_ExpDefaultWinHandle2;
        public HObject ho_Image = null;
        public HTuple hv_AcqHandle = null;
        public HTuple hv_Width = new HTuple();
        public HTuple hv_Height = new HTuple();

        Form1 fx1 = new Form1();
        public static int Ontestview=0;
        public static int oneTestDone = 0;
        public static Boolean OntestviewEnd = false;
        public static Boolean analysisDone = false;
        public static string testResult = "", testResult2 = "";
        public static string[] testResult3=new string[50];  //测试结果放到数组给窗体1

        Boolean CloseCamare = false;  //true则关闭摄像头
        //读取所需 好坏板 模板,Model方法在halcon类里面
        //HDevelopExport HD = new HDevelopExport();
        Thread t4;
        public void Form2_Load(object sender, EventArgs e)
        {
            this.MaximizeBox = false;
            Model();
            //——————————————————————————————————

            //打开摄像头
            hv_ExpDefaultWinHandle = hWindowControl1.HalconWindow;   //显示窗口一 
            //hv_ExpDefaultWinHandle2 = hWindowControl2.HalconWindow;  //显示抓拍的窗口 
            HOperatorSet.GenEmptyObj(out ho_Image);
            //Image Acquisition 01: Code generated by Image Acquisition 01 
            HOperatorSet.CloseAllFramegrabbers();
            /*  HOperatorSet.OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "progressive",
         8, "Gray", -1, "false", "auto", "USB2.0 Camera", 0, -1, out hv_AcqHandle);*/
            //打开摄像机，我的是MindVision USB的，自己根据自己实际来写 
            HOperatorSet.OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "RGB",
         -1, "false", "default", "default", 0, -1, out hv_AcqHandle);
             //HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "grab_timeout", 1000);
             hv_Height = 720;  //相机分辨率 
             hv_Width = 1280;
             HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_Height, hv_Width);  //设置图像显示部分 
             //HOperatorSet.SetPart(hv_ExpDefaultWinHandle2, 0, 0, hv_Height, hv_Width);
            //----------------------------------------------------------------------------
             oneTestDone = 1;
             Control.CheckForIllegalCrossThreadCalls = false;   //线程间控件操作有效
             backgroundWorker1.RunWorkerAsync();
             backgroundWorker2.RunWorkerAsync();
             this.ShowInTaskbar = false;     //不在windows的任务栏显示

        }


        private void backgroundWorker2_DoWork(object sender, DoWorkEventArgs e)
        {
            //多线程显示图像
            while (true)
            {


                HOperatorSet.GrabImageStart(hv_AcqHandle, -1);
                // ho_Image.Dispose();   释放内存资源
                //HOperatorSet.GrabImageAsync(out ho_Image, hv_AcqHandle, -1);
                HOperatorSet.GrabImage(out ho_Image, hv_AcqHandle);
                //Image Acquisition 01: Do something 
                HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);   //视频显示 
                //Application.DoEvents();


                ho_Image.Dispose();   //释放内存资源
                ho_Image = null;   //显示完一次清空一次
                if (CloseCamare == true)
                {   //关闭窗口2时，先关闭摄像头，否则下次打开出错，并关闭多线程
                    HOperatorSet.CloseFramegrabber(hv_AcqHandle);
  
                    break;

                }
            }

        }




        private void Form2_FormClosed(object sender, FormClosedEventArgs e)
        {
            CloseCamare = true;   //窗体关闭时，关闭多线程里的摄像头
           
        }


        private void button1_Click(object sender, EventArgs e)
        {
            action();
        }

        public void OnTestView()
        {   //窗口一启动运行前检查是否在测试界面 
            //抓取一张图片
          
            ho_Image1 = null;
            //HOperatorSet.GrabImageAsync(out ho_Image1, hv_AcqHandle, -1);
            HOperatorSet.GrabImage(out ho_Image1, hv_AcqHandle);
            //以下判断是否是好板     
            HOperatorSet.FindNccModel(ho_Image1, hv_ModelID5, -0.39, 0.78, 0.8, 1, 0.5,
                "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);

            if ((int)(new HTuple(hv_Score.TupleGreater(0.5))) != 0)
            { //如果相似度大于0.5，则为好板
                Ontestview = 1;        //测试结果告诉窗体1,在窗体1置0
            }
            OntestviewEnd = true;      //测试完毕告诉窗体1，在窗体1false


        }

    //以下检查是否 在 测试界面--------------------------------------------
        int testTimesFrom1 = 1;  //接收窗体1的测试次数
        int wrongRetestFrom1 = 1; //接收窗体1的错误重测次数  
        private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e)
        {
            while (true)
            {
                //HOperatorSet.GrabImageAsync(out ho_Image1, hv_AcqHandle, -1);
                HOperatorSet.GrabImage(out ho_Image2, hv_AcqHandle);
                //以下判断是否是好板     
                HOperatorSet.FindNccModel(ho_Image2, hv_ModelID5, -0.39, 0.78, 0.8, 1, 0.5,
                    "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score1);

                if ((int)(new HTuple(hv_Score1.TupleGreater(0.5))) != 0)
                {
                    Ontestview = 1;        //测试结果告诉窗体1,在窗体1置0
                }
                else
                {
                    Ontestview = 0;
                }
                OntestviewEnd = true;      //测试完毕告诉窗体1，在窗体1false

               

                ho_Image2.Dispose();   //释放内存资源
                ho_Image2 = null;
                hv_Row = null;
                hv_Column = null;
                hv_Angle = null;
                hv_Score1 = null;
                Thread.Sleep(200);
            }
        }




        public  int OntestviewToForm1
        {   //给窗体1访问
            get { return Ontestview;}
            set { Ontestview = value; }
        }
        public  Boolean OntestviewEndToForm1
        {   //给窗体1访问
            get { return OntestviewEnd; }
            set { OntestviewEnd = value; }
        }

        public Boolean AnalysisDone
        {  //分析一次完成，给主窗体1访问
            get { return analysisDone; }
            set { analysisDone = value; }
        
        }

        public string[] TestResult3
        {   //一张最终测试结果
            get { return testResult3; }
            set { testResult3 = value; }
        }

        public string TestResult2
        {   //一张最终测试结果,仅为显示
            get { return testResult2; }
            set { testResult2 = value; }
        }

        public int OneTestDone
        {
            get { return oneTestDone; }
            set { oneTestDone = value; }
        }

    //以上检查是否在测试界面------------------------------------------------------





       /* public partial class HDevelopExport
        {
#if !NO_EXPORT_APP_MAIN
            public HDevelopExport()
            {
                // Default settings used in HDevelop 
                HOperatorSet.SetSystem("do_low_error", "false");
                action();
            }
#endif

            public void HDevelopStop()
            {
            }

        */
            public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
                HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
            {


                // Local control variables 

                HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
                HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
                HTuple hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
                HTuple hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1 = new HTuple();
                HTuple hv_C1 = new HTuple(), hv_FactorRow = new HTuple(), hv_FactorColumn = new HTuple();
                HTuple hv_Width = new HTuple(), hv_Index = new HTuple(), hv_Ascent = new HTuple();
                HTuple hv_Descent = new HTuple(), hv_W = new HTuple(), hv_H = new HTuple();
                HTuple hv_FrameHeight = new HTuple(), hv_FrameWidth = new HTuple();
                HTuple hv_R2 = new HTuple(), hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
                HTuple hv_Exception = new HTuple(), hv_CurrentColor = new HTuple();

                HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
                HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
                HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
                HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

                // Initialize local and output iconic variables 

                //This procedure displays text in a graphics window.
                //
                //Input parameters:
                //WindowHandle: The WindowHandle of the graphics window, where
                //   the message should be displayed
                //String: A tuple of strings containing the text message to be displayed
                //CoordSystem: If set to 'window', the text position is given
                //   with respect to the window coordinate system.
                //   If set to 'image', image coordinates are used.
                //   (This may be useful in zoomed images.)
                //Row: The row coordinate of the desired text position
                //   If set to -1, a default value of 12 is used.
                //Column: The column coordinate of the desired text position
                //   If set to -1, a default value of 12 is used.
                //Color: defines the color of the text as string.
                //   If set to [], '' or 'auto' the currently set color is used.
                //   If a tuple of strings is passed, the colors are used cyclically
                //   for each new textline.
                //Box: If set to 'true', the text is written within a white box.
                //
                //prepare window
                HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
                HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
                    out hv_Column2Part);
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
                    out hv_WidthWin, out hv_HeightWin);
                HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
                //
                //default settings
                if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
                {
                    hv_Row_COPY_INP_TMP = 12;
                }
                if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
                {
                    hv_Column_COPY_INP_TMP = 12;
                }
                if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                {
                    hv_Color_COPY_INP_TMP = "";
                }
                //
                hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
                //
                //Estimate extentions of text depending on font size.
                HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
                    out hv_MaxWidth, out hv_MaxHeight);
                if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
                {
                    hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                    hv_C1 = hv_Column_COPY_INP_TMP.Clone();
                }
                else
                {
                    //transform image to window coordinates
                    hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                    hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                    hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                    hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
                }
                //
                //display text box depending on text size
                if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
                {
                    //calculate box extents
                    hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                    hv_Width = new HTuple();
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                            hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                        hv_Width = hv_Width.TupleConcat(hv_W);
                    }
                    hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                        ));
                    hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                    hv_R2 = hv_R1 + hv_FrameHeight;
                    hv_C2 = hv_C1 + hv_FrameWidth;
                    //display rectangles
                    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                    HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                    HOperatorSet.SetColor(hv_WindowHandle, "light gray");
                    HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 3, hv_C1 + 3, hv_R2 + 3, hv_C2 + 3);
                    HOperatorSet.SetColor(hv_WindowHandle, "white");
                    HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                    HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
                }
                else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception = "Wrong value of control parameter Box";
                    throw new HalconException(hv_Exception);
                }
                //Write text.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                        )));
                    if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                        "auto")))) != 0)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
                    }
                    else
                    {
                        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                    }
                    hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                    HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
                    HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index));
                }
                //reset changed window settings
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                    hv_Column2Part);

                return;
            }

            // Chapter: Graphics / Text
            // Short Description: Set font independent of OS

                
            public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
                HTuple hv_Bold, HTuple hv_Slant)
            {


                // Local control variables 

                HTuple hv_OS, hv_Exception = new HTuple();
                HTuple hv_AllowedFontSizes = new HTuple(), hv_Distances = new HTuple();
                HTuple hv_Indices = new HTuple();

                HTuple hv_Bold_COPY_INP_TMP = hv_Bold.Clone();
                HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
                HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();
                HTuple hv_Slant_COPY_INP_TMP = hv_Slant.Clone();

                // Initialize local and output iconic variables 

                //This procedure sets the text font of the current window with
                //the specified attributes.
                //It is assumed that following fonts are installed on the system:
                //Windows: Courier New, Arial Times New Roman
                //Linux: courier, helvetica, times
                //Because fonts are displayed smaller on Linux than on Windows,
                //a scaling factor of 1.25 is used the get comparable results.
                //For Linux, only a limited number of font sizes is supported,
                //to get comparable results, it is recommended to use one of the
                //following sizes: 9, 11, 14, 16, 20, 27
                //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
                //
                //input parameters:
                //WindowHandle: The graphics window for which the font will be set
                //Size: The font size. If Size=-1, the default of 16 is used.
                //Bold: If set to 'true', a bold font is used
                //Slant: If set to 'true', a slanted font is used
                //
                HOperatorSet.GetSystem("operating_system", out hv_OS);
                if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                {
                    hv_Size_COPY_INP_TMP = 16;
                }
                if ((int)(new HTuple((((hv_OS.TupleStrFirstN(2)).TupleStrLastN(0))).TupleEqual(
                    "Win"))) != 0)
                {
                    //set font on Windows systems
                    if ((int)((new HTuple((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(
                        new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
                        "courier")))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "Courier New";
                    }
                    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "Arial";
                    }
                    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "Times New Roman";
                    }
                    if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
                    {
                        hv_Bold_COPY_INP_TMP = 1;
                    }
                    else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
                    {
                        hv_Bold_COPY_INP_TMP = 0;
                    }
                    else
                    {
                        hv_Exception = "Wrong value of control parameter Bold";
                        throw new HalconException(hv_Exception);
                    }
                    if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
                    {
                        hv_Slant_COPY_INP_TMP = 1;
                    }
                    else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
                    {
                        hv_Slant_COPY_INP_TMP = 0;
                    }
                    else
                    {
                        hv_Exception = "Wrong value of control parameter Slant";
                        throw new HalconException(hv_Exception);
                    }
                    try
                    {
                        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-" + hv_Font_COPY_INP_TMP) + "-") + hv_Size_COPY_INP_TMP) + "-*-") + hv_Slant_COPY_INP_TMP) + "-*-*-") + hv_Bold_COPY_INP_TMP) + "-");
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException(hv_Exception);
                    }
                }
                else
                {
                    //set font for UNIX systems
                    hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP * 1.25;
                    hv_AllowedFontSizes = new HTuple();
                    hv_AllowedFontSizes[0] = 11;
                    hv_AllowedFontSizes[1] = 14;
                    hv_AllowedFontSizes[2] = 17;
                    hv_AllowedFontSizes[3] = 20;
                    hv_AllowedFontSizes[4] = 25;
                    hv_AllowedFontSizes[5] = 34;
                    if ((int)(new HTuple(((hv_AllowedFontSizes.TupleFind(hv_Size_COPY_INP_TMP))).TupleEqual(
                        -1))) != 0)
                    {
                        hv_Distances = ((hv_AllowedFontSizes - hv_Size_COPY_INP_TMP)).TupleAbs();
                        HOperatorSet.TupleSortIndex(hv_Distances, out hv_Indices);
                        hv_Size_COPY_INP_TMP = hv_AllowedFontSizes.TupleSelect(hv_Indices.TupleSelect(
                            0));
                    }
                    if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
                        "Courier")))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "courier";
                    }
                    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "helvetica";
                    }
                    else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = "times";
                    }
                    if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
                    {
                        hv_Bold_COPY_INP_TMP = "bold";
                    }
                    else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
                    {
                        hv_Bold_COPY_INP_TMP = "medium";
                    }
                    else
                    {
                        hv_Exception = "Wrong value of control parameter Bold";
                        throw new HalconException(hv_Exception);
                    }
                    if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
                    {
                        if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("times"))) != 0)
                        {
                            hv_Slant_COPY_INP_TMP = "i";
                        }
                        else
                        {
                            hv_Slant_COPY_INP_TMP = "o";
                        }
                    }
                    else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
                    {
                        hv_Slant_COPY_INP_TMP = "r";
                    }
                    else
                    {
                        hv_Exception = "Wrong value of control parameter Slant";
                        throw new HalconException(hv_Exception);
                    }
                    try
                    {
                        HOperatorSet.SetFont(hv_WindowHandle, ((((((("-adobe-" + hv_Font_COPY_INP_TMP) + "-") + hv_Bold_COPY_INP_TMP) + "-") + hv_Slant_COPY_INP_TMP) + "-normal-*-") + hv_Size_COPY_INP_TMP) + "-*-*-*-*-*-*-*");
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException(hv_Exception);
                    }
                }

                return;
            }
            //-------------------------以下定义变量，全局通用------------------------------
            // Main procedure 
            HTuple hv_ModelID1, hv_ModelID, hv_ModelID2, hv_ModelID3, hv_ModelID4, hv_ModelID5;
            // Local iconic variables 

            HObject ho_Image1, ho_Image2, ho_Rectangle = null, ho_TemplateImage = null;
            HObject ho_Regions = null, ho_ConnectedRegions = null, ho_SortedRegions = null;
            HObject ho_BinImage = null;
            HObject ho_Red, ho_Grenn, ho_Blue, ho_ImageAbsDiff, ho_SelectedRegions1;

            // Local control variables 

            HTuple hv_Row, hv_Column;
           // HTuple hv_AcqHandle = null;
            HTuple hv_Angle, hv_Score, hv_Row1, hv_Column1, hv_Angle1, hv_Row2, hv_Column2, hv_Angle2;
            HTuple hv_Score1, hv_Score2, hv_OCRHandle = new HTuple(), hv_Class = new HTuple();
            HTuple hv_Confidence = new HTuple(), hv_Area = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple(), hv_i = new HTuple();
            HTuple hv_ii = new HTuple(), hv_k = new HTuple(), hv_Distance1 = new HTuple();
            HTuple hv_Distance2 = new HTuple(), hv_Num = new HTuple();
            HTuple hv_Distance3 = new HTuple();
            //-------------------------以上定义变量，全局通用------------------------------
           
            int wrongRetestNow = 0;  //正在测试第几次，对于重测而言
            int testTimesNow = 0;    //正在测试第几次，对于冲数而言
            public void action()
            {
                // Initialize local and output iconic variables 
                HOperatorSet.GenEmptyObj(out ho_Image1);
                HOperatorSet.GenEmptyObj(out ho_Rectangle);
                HOperatorSet.GenEmptyObj(out ho_TemplateImage);
                HOperatorSet.GenEmptyObj(out ho_Regions);
                HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
                HOperatorSet.GenEmptyObj(out ho_SortedRegions);
                HOperatorSet.GenEmptyObj(out ho_BinImage);


                //try
                //{
                    //创建一般模板
                    //read_image (Image1, 'C:/Users/Administrator/Desktop/201592/电测机测试/白色翻页.bmp')

                    //crop_part (Image1, ImagePart, 448, 115, 114, 30)
                    //crop_part (Image1, ImagePart, 420, 115, 114, 30)
                    //create_ncc_model (ImagePart, 'auto', -0.39, 6.29, 'auto', 'use_polarity', ModelID1)


                    //write_ncc_model (ModelID1, 'C:/Users/Administrator/Desktop/201592/电测机测试/好板白色文字模板.ncm')
                    //(y,x,y增量，x增量）
                    //********************************************

                    //创建可变形模板
                    //read_image (Image1, 'C:/Users/Administrator/Desktop/201592/电测机测试/5.bmp')
                    //crop_part (Image1, ImagePart, 336, 115, 114, 30)
                    //create_local_deformable_model (ImagePart, 'auto', -0.39, 0.79, 'auto', 1, 1, 'auto', 1, 1, 'auto', 'none', 'use_polarity', 'auto', 'auto', [], [], ModelID2)
                    //write_deformable_model (ModelID2, 'C:/Users/Administrator/Desktop/201592/电测机测试/坏板可变形文字模板.dfm')
                    if (HDevWindowStack.IsOpen())
                    {
                        //dev_display (Image1)
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        //dev_set_draw ('margin')
                    }



                    //read_image (Image1, 'C:/Users/Administrator/Desktop/201592/电测机测试/分析错误.png')
                    //read_deformable_model ('C:/Users/Administrator/Desktop/201592/电测机测试/坏板可变形文字模板.dfm', ModelID2)
                    //find_local_deformable_model (Image1, ImageRectified, VectorField, DeformedContours, ModelID2, 0, 0, 1, 1, 1, 1, 0.5, 1, 1, 0, 0.9, [], [], [], Score3, Row3, Column3)




                    //********************************************
                    //read_image (Image1, 'C:/Users/Administrator/Desktop/201592/电测机测试/分析错误.png')

                    //ho_Image1.Dispose();
                    //抓取一张图片
                    testResult = "";
                    ho_Image1 = null;
                    //HOperatorSet.GrabImageAsync(out ho_Image1, hv_AcqHandle, -1);
                    HOperatorSet.GrabImage(out ho_Image1, hv_AcqHandle);
                    //以下判断是否是好板     
                    HOperatorSet.FindNccModel(ho_Image1, hv_ModelID, -0.39, 0.78, 0.8, 1, 0.5,
                        "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);

                    if ((int)(new HTuple(hv_Score.TupleGreater(0.5))) != 0)
                    { //如果相似度大于0.5，则为好板
                        testResult = "OK";
                      
                    }

                    else
                    {
                        //抓取一张图片
                        ho_Image1 = null;
                        //HOperatorSet.GrabImageAsync(out ho_Image1, hv_AcqHandle, -1);
                        HOperatorSet.GrabImage(out ho_Image1, hv_AcqHandle);
                        //以下判断是否是 有坏板红色文字    
                        HOperatorSet.FindNccModel(ho_Image1, hv_ModelID1, -0.39, 0.78, 0.8, 1, 0.5,
                            "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                        Application.DoEvents();

                        if ((int)(new HTuple(hv_Score.TupleGreater(0.5))) != 0)
                        { //如果相似度大于0.5，则有坏板红色文字，不需要翻页
                            HOperatorSet.GenRectangle1(out ho_Rectangle, 218, 105, 520, 792); //剪切需要分析的区域
                            //ho_TemplateImage.Dispose();
                            HOperatorSet.ReduceDomain(ho_Image1, ho_Rectangle, out ho_TemplateImage);// 把剪切的区域从全屏中分离出来
                            HOperatorSet.Decompose3(ho_TemplateImage, out ho_Red, out ho_Grenn, out ho_Blue);  //生成三通道图片
                            HOperatorSet.AbsDiffImage(ho_Red, ho_Grenn, out ho_ImageAbsDiff, 1);//得到两张图片不同的区域
                            // ho_Regions.Dispose();
                            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_Regions, 82, 255);   //阈值
                            // ho_ConnectedRegions.Dispose();
                            HOperatorSet.Connection(ho_Regions, out ho_ConnectedRegions);   //连接后得到一个个单独的个体区域，之前所有符合像素的区域是一体的
                            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions1, (new HTuple("width")).TupleConcat(
                "height"), "and", (new HTuple(7.8)).TupleConcat(7.5), (new HTuple(14.5)).TupleConcat(
                13.5));
                            //字库选择
                            HOperatorSet.SortRegion(ho_SelectedRegions1, out ho_SortedRegions, "first_point",
                "true", "row");
                            // HOperatorSet.ReadOcrClassMlp("DotPrint_0-9.omc", out hv_OCRHandle);

                            HOperatorSet.RegionToBin(ho_SortedRegions, out ho_BinImage, 0, 255, 430, 700);

                            HOperatorSet.DoOcrMultiClassMlp(ho_SortedRegions, ho_BinImage, hv_OCRHandle,
                out hv_Class, out hv_Confidence);
                            HOperatorSet.AreaCenter(ho_SortedRegions, out hv_Area, out hv_Rows, out hv_Columns);

                            /////////////////此段分析数字


                            Pictureanalysis();      //调用图像分析函数
                            //-------------------------------------------------------

                        }

                        else
                        {  //需要翻页，翻页前先分析当前页面有无红色 数字    
                            try
                            {
                                HOperatorSet.GenRectangle1(out ho_Rectangle, 218, 105, 520, 792); //剪切需要分析的区域
                                // ho_TemplateImage.Dispose();
                                HOperatorSet.ReduceDomain(ho_Image1, ho_Rectangle, out ho_TemplateImage);// 把剪切的区域从全屏中分离出来
                                HOperatorSet.Decompose3(ho_TemplateImage, out ho_Red, out ho_Grenn, out ho_Blue);  //生成三通道图片
                                HOperatorSet.AbsDiffImage(ho_Red, ho_Grenn, out ho_ImageAbsDiff, 1);//得到两张图片不同的区域
                                // ho_Regions.Dispose();
                                HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_Regions, 82, 255);   //阈值
                                // ho_ConnectedRegions.Dispose();
                                HOperatorSet.Connection(ho_Regions, out ho_ConnectedRegions);   //连接后得到一个个单独的个体区域，之前所有符合像素的区域是一体的
                                HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions1, (new HTuple("width")).TupleConcat(
                    "height"), "and", (new HTuple(7.8)).TupleConcat(7.5), (new HTuple(14.5)).TupleConcat(
                    13.5));
                                //字库选择
                                HOperatorSet.SortRegion(ho_SelectedRegions1, out ho_SortedRegions, "first_point",
                    "true", "row");
                                // HOperatorSet.ReadOcrClassMlp("DotPrint_0-9.omc", out hv_OCRHandle);

                                HOperatorSet.RegionToBin(ho_SortedRegions, out ho_BinImage, 0, 255, 430, 700);
                                HOperatorSet.DoOcrMultiClassMlp(ho_SortedRegions, ho_BinImage, hv_OCRHandle,
                    out hv_Class, out hv_Confidence);
                                HOperatorSet.AreaCenter(ho_SortedRegions, out hv_Area, out hv_Rows, out hv_Columns);

                                /////////////////此段分析数字
                                Pictureanalysis();      //调用图像分析函数
                            }
                            catch
                            {
                                //当前页面没有红色数字
                                //MessageBox.Show("当前页面没有红色数字");
                            }



                            //-------------------------------------------------------

                                //当前页面红色数字分析完，翻页
                                 double score2=0;
                               do
                               {
                                
                                fx1.Write_DataPc1("M351", 1); //翻页
                                Thread.Sleep(10);
                                fx1.Write_DataPc1("M351", 0); //翻页
                                Thread.Sleep(50);
                                    try
                                    {
                                        ho_Image1 = null;
                                        HOperatorSet.GrabImage(out ho_Image1, hv_AcqHandle);
                                        HOperatorSet.FindNccModel(ho_Image1, hv_ModelID3, -0.39, 0.78, 0.8, 1, 0.5,
                      "true", 0, out hv_Row2, out hv_Column2, out hv_Angle2, out hv_Score2); //坏板白色文字模板
                                        score2 = (Double)hv_Score2;
                                    }
                                    catch
                                    { }
                               }
                               while (score2 < 0.3);

                               double Row = 0;
                               double Row1 = 0;
                               double score1 = 0;
                               try
                               {
                                   //抓取一张图片
                                   //ho_Image1 = null; hv_Row = null; hv_Column = null; hv_Angle = null; hv_Score = null;
                                   //hv_Row1 = null; hv_Column1 = null; hv_Angle1 = null; hv_Score1 = null;
                                   HOperatorSet.GrabImage(out ho_Image1, hv_AcqHandle);
                                   HOperatorSet.FindNccModel(ho_Image1, hv_ModelID3, -0.39, 0.78, 0.8, 1, 0.5,
                 "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score); //坏板白色文字模板 
                                   Row = (Double)hv_Row;
                                   HOperatorSet.FindNccModel(ho_Image1, hv_ModelID4, -0.39, 0.78, 0.8, 1, 0.5,
                 "true", 0, out hv_Row1, out hv_Column1, out hv_Angle1, out hv_Score1);//好板白色文字模板
                                   Row1 = (Double)hv_Row1;
                                   score1 = (Double)hv_Score1;
                                   if (score1 >= 0.3)
                                   {
                                       HOperatorSet.GenRectangle1(out ho_Rectangle, Row + 15, 115, Row1 - 15,
                                           430);
                                   }
                                   else
                                   {
                                       HOperatorSet.GenRectangle1(out ho_Rectangle, Row + 15, 115, 563,
                                           430);
                                   }
                               }
                               catch
                               {
                                   //翻页后找不到好板白色文字模板,导致数据出错，如果出错来这里截取
                                   //坏板白色文字模板以下的区域
                                   HOperatorSet.GenRectangle1(out ho_Rectangle, Row + 15, 115, 563,
                                          430);
                               }

                                HOperatorSet.ReduceDomain(ho_Image1, ho_Rectangle, out ho_TemplateImage);// 把剪切的区域从全屏中分离出来                                              
                                // ho_Regions.Dispose();
                                HOperatorSet.Threshold(ho_TemplateImage, out ho_Regions, 85, 255);   //阈值
                                // ho_ConnectedRegions.Dispose();
                                HOperatorSet.Connection(ho_Regions, out ho_ConnectedRegions);   //连接后得到一个个单独的个体区域，之前所有符合像素的区域是一体的
                                //字库选择
                                HOperatorSet.SortRegion(ho_ConnectedRegions, out ho_SortedRegions, "first_point",
                    "true", "row");
                                // HOperatorSet.ReadOcrClassMlp("DotPrint_0-9.omc", out hv_OCRHandle);

                                HOperatorSet.RegionToBin(ho_SortedRegions, out ho_BinImage, 0, 255, 430, 700);
                                HOperatorSet.DoOcrMultiClassMlp(ho_SortedRegions, ho_BinImage, hv_OCRHandle,
                    out hv_Class, out hv_Confidence);
                                HOperatorSet.AreaCenter(ho_SortedRegions, out hv_Area, out hv_Rows, out hv_Columns);


                                Pictureanalysis();      //调用图像分析函数
                            }
               

                    }


                    wrongRetestNow = wrongRetestNow + 1;    //正在测试第几次，对于重测而言

                    if (testResult == "OK")
                    {
                        fx1.Write_DataPc2("M25", 1);
                        wrongRetestNow = wrongRetestFrom1;
                        oneTestDone = 1;
                    }
                    else
                    {
                        fx1.Write_DataPc2("M24", 1);
                        oneTestDone = 1;
                    }

                    fx1.Write_DataPc2("M23", 1);  //仅一冲测试完                 
                    if (wrongRetestNow == wrongRetestFrom1)
                    {   //如果错误重测次数到了，最终结果记录这次的次数结果  
                        if (testResult == "")
                        {
                            MessageBox.Show("结果为空");
                        }
                        testResult2 = testResult2 + "(" + testResult + ")";   //显示在窗体2文本上
                        wrongRetestNow = 0;
                        testResult3[testTimesNow] = testResult;
                        testTimesNow = testTimesNow + 1;      //正在测试第几次，对于冲数而言
                        if (testTimesNow == testTimesFrom1)
                        {
                            analysisDone = true;     //一张分析完成
                            testTimesNow = 0;
                            //testResult2 = "";
                        }
                    }
                    //M23_writeOn = true;

                    ho_Red.Dispose();
                    ho_Grenn.Dispose();
                    ho_Blue.Dispose();
                    ho_Image1.Dispose();
                    ho_Rectangle.Dispose();
                    ho_TemplateImage.Dispose();
                    ho_Regions.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho_SortedRegions.Dispose();
                    ho_BinImage.Dispose();
                    ho_ImageAbsDiff.Dispose();

                //}

                //catch (HalconException HDevExpDefaultException)
                //{
                //    MessageBox.Show("分析数字 大循环出错");
                //    ho_Red.Dispose();
                //    ho_Grenn.Dispose();
                //    ho_Blue.Dispose();
                //    ho_Image1.Dispose();
                //    ho_Rectangle.Dispose();
                //    ho_TemplateImage.Dispose();
                //    ho_Regions.Dispose();
                //    ho_ConnectedRegions.Dispose();
                //    ho_SortedRegions.Dispose();
                //    ho_BinImage.Dispose();
                //    ho_ImageAbsDiff.Dispose();

                //    //  throw HDevExpDefaultException;
                //}
                    t4.Abort();
            }

#if !NO_EXPORT_APP_MAIN
            /* public class HDevelopExportApp
        {
            static void Main(string[] args)
            {
                new HDevelopExport();
            }
        }*/
#endif

            //------------以下读取所需 好坏板 模板,窗体2调用-------------------------
            public void Model()
            {
                // Local control variables   //读取所需 好坏板 模板,窗体2调用

               
                hv_ModelID = null;           //第一次启动 清空
                hv_ModelID1 = null;
                hv_ModelID2 = null;
                hv_ModelID3 = null;
                hv_ModelID4 = null;
                hv_ModelID5 = null;




                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/2.ncm",
                //    out hv_ModelID);      //好板模板
                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/坏板红色文字模板.ncm",
                //   out hv_ModelID1);      //坏板红色文字模板

                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/坏板大号文字模板.ncm",
                //  out hv_ModelID2);      //坏板大号文字模板
                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/坏板白色文字模板.ncm",
                // out hv_ModelID3);      //坏板白色文字模板
                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/好板白色文字模板.ncm",
                // out hv_ModelID4);      //好板白色文字模板
                //HOperatorSet.ReadNccModel("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/10.ncm",
                // out hv_ModelID5);      //测试界面
                //HOperatorSet.ReadOcrClassMlp("F:/软件安装包/测试机程序/CSharp电测机/COM USB通讯优化/WindowsFormsApplication1/Halcon/DotPrint_0-9.omc", out hv_OCRHandle);

                HOperatorSet.ReadNccModel("2.ncm", out hv_ModelID); //好板模板
                HOperatorSet.ReadNccModel("坏板红色文字模板.ncm",out hv_ModelID1);      //坏板红色文字模板
                HOperatorSet.ReadNccModel("坏板大号文字模板.ncm",out hv_ModelID2);      //坏板大号文字模板
                HOperatorSet.ReadNccModel("坏板白色文字模板.ncm",out hv_ModelID3);      //坏板白色文字模板
                HOperatorSet.ReadNccModel("好板白色文字模板.ncm",out hv_ModelID4);      //好板白色文字模板
                HOperatorSet.ReadNccModel("10.ncm",out hv_ModelID5);      //测试界面
                HOperatorSet.ReadOcrClassMlp("DotPrint_0-9.omc", out hv_OCRHandle);
            }
            //------------以上读取所需 好坏板 模板,窗体2调用-------------------------


        //------------以下分析截取画面的坏单元-------------------------
            public void Pictureanalysis()
            {
                double Distance1, Distance2, Distance3;
                int i = 1,K = 0;
                Boolean even;              //只有一个单独的数时为true,不必再分析
                //以下判断前两个数数  是由单独两个数组成，还是相连的两个十位数
                //先判断这个问题，后面才好分析

                even = false;
                if((i==1) && (hv_Class.Length>1))
                {   //i==1,从第一个数开始判断，且单独数字个数大于1，肯定可以拿前两个组合

                    Distance1 = (Double)hv_Columns[i] - (Double)hv_Columns[i - 1];   //后一个数对前一个数的 列坐标距离
                    Distance2 = (Double)hv_Rows[i] - (Double)hv_Rows[i - 1];         //下一个数对上一个数的 行坐标距离

                    if ((Distance1 > 35) && (Distance2 < 5))
                    {  //第一个数 是单独个位数
                        testResult = (String)hv_Class[i - 1]+",";

                    }
                    else
                    {  //第一个数 是由两个单独数组成的两位数
                        testResult = (String)hv_Class[i - 1] + (String)hv_Class[i - 1] + ",";
                        K = K + 1;
                        if (hv_Class.Length == 2)
                        { //只有两个单独数，而且可以合在一起的两位数，可以调出分析循环了
                            even = true;
                        }
                    }
                }
                Application.DoEvents();

                if ((i == 1) && (hv_Class.Length == 1))
                {  //有且只有一个单独的数
                    testResult = (String)hv_Class[i - 1] + ",";
                    even = true;
                }
  

        if(even==false)   //不是单个数字
           {   //K的值是十位数的次数，每判别一次十位数，K+1
               //如下if语句是判断是否最后一个数，如果是，且为单数则输出，若为双数，下面会提前跳出if判断循环语句

               for (i = 2; i <= hv_Class.Length; i++)
               {            
                   i = i + K;
                   K = 0;

                   if (i == hv_Class.Length)
                   {
                       testResult = testResult + (String)hv_Class[i - 1] + ",";
                       break;
                   }
                   else if (i == hv_Class.Length+1)
                   {
                       break;
                   }



                   if ((i != hv_Class.Length) && (i != hv_Class.Length + 1))
                   {
                       Distance1 = (Double)hv_Columns[i - 2] - (Double)hv_Columns[i - 1];
                       //前一个数的列坐标-正在判断的数的列坐标
                       Distance3 = (Double)hv_Columns[i] - (Double)hv_Columns[i - 1];
                       //后一个数的列坐标-正在判断的数的列坐标 
                       Distance2 = (Double)hv_Rows[i] - (Double)hv_Rows[i - 1];
                       //后一个数的行坐标-正在判断的数的行坐标

                       if ((Distance1 > -100) && (Distance2 < 5) && (Distance3 > 35))
                       { //个位数判断
                           testResult = testResult + (String)hv_Class[i - 1] + ",";
                       }
                       else if ((Distance1 > -100) && (Distance2 > 5))
                       { //否则是第一行的最后一个数，即对换行即第一排最后一个数的判断
                           testResult = testResult + (String)hv_Class[i - 1] + ",";
                       }
                       else
                       {
                           testResult = testResult + (String)hv_Class[i - 1] + (String)hv_Class[i] + ",";
                           K = K + 1;
                       }

                   }
                   Application.DoEvents();
               }    //next for
               testResult = testResult.Substring(0, testResult.Length - 1);

           }


      }


            public void RstForm1()
            {   //全复位 清零
                testResult = "";
                testResult2 = "";
                analysisDone = false;
                wrongRetestNow = 0;
                testTimesNow = 0;
            }


            public void analysisBegin()
            {
                t4 = new Thread(new ThreadStart(action));
                t4.Start();
            }

            private static bool DelaySeconds1(double delayTime)
            {
                DateTime now = DateTime.Now;
                double s1;
                do
                {
                    TimeSpan spand1 = DateTime.Now - now;
                    s1 = spand1.Seconds;
                    Application.DoEvents();
                }
                while (s1 < delayTime);
                return true;
            }

         

         


        //------------以上分析截取画面的坏单元-------------------------






    }
}
       // #endregion